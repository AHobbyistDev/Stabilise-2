package com.stabilise.util;

/**
 * An instance of this class may be used to provide a main loop which can be
 * utilised on to by implementing {@link #update()} and {@link #render()}.
 * 
 * <p>A typical main loop can be generated by invoking {@link #run()}; however,
 * an AppDriver can be hooked onto 
 * 
 * <p>An instance of this class is not thread-safe.
 */
public abstract class AppDriver implements Runnable {
	
	public final int ticksPerSecond;
	private final long nsPerTick; // nanos per tick
	public final int framesPerSecond;
	private final long nsPerFrame; // nanos per frame
	
	/** The time when last it was checked as per {@code System.nanoTime()}. */
	private long lastTime = 0L;
	/** The number of 'unprocessed' nanoseconds. An update tick is executed
	 * when this is greater than or equal to nsPerTick. */
	private long unprocessed = 0L;
	/** The number of updates and renders which have been executed in the 
	 * lifetime of this driver. */
	private long numUpdates = 0L, numRenders = 0L;
	
	/** {@code true} if this driver is running. You can set this to {@code
	 * false} to stop this from running if it is being run as per {@link
	 * #run()}. */
	public boolean running = false;
	/** {@code true} if a tick is in the process of executing. */
	private boolean ticking = false;
	
	/** This driver's profiler. It is disabled by default.
	 * <p>This profiler is flushed automatically once per second; to use it,
	 * simply invoke {@code start}, {@code next} and {@code end} where desired. */
	public final Profiler profiler = new Profiler(false, "root");
	/** The last update at which the profiler was flushed. */
	private long lastProfilerFlush = 0L;
	
	private final Log log;
	
	
	/**
	 * Creates a new AppDriver.
	 * 
	 * @param updatesPerSecond The number of update ticks per second.
	 * @param fps The maximum number of frames per second if this is run via
	 * {@link #run()}.
	 * @param log The log for this driver to use.
	 * 
	 * @throws IllegalArgumentException if either {@code ticksPerSecond < 1} or
	 * {@code fps < 1}>
	 * @throws NullPointerException if {@code log} is {@code null}.
	 */
	public AppDriver(int updatesPerSecond, int fps, Log log) {
		if(updatesPerSecond < 1)
			throw new IllegalArgumentException("ticksPerSecond < 1");
		if(fps < 1)
			throw new IllegalArgumentException("fps < 1");
		if(log == null)
			throw new NullPointerException("log is null");
		
		this.ticksPerSecond = updatesPerSecond;
		nsPerTick = 1000000000L / updatesPerSecond;
		this.framesPerSecond = fps;
		nsPerFrame = 1000000000L / fps;
		
		this.log = log;
	}
	
	/**
	 * Initiates a loop which invokes {@link #tick()} up to as many times per
	 * second as {@code fps} as specified in the constructor. This method will
	 * not return until either of the following occurs:
	 * 
	 * <ul>
	 * <li>{@link #running} is set to {@code false}; or, equivalently,
	 * <li>{@link #stop()} is invoked; or
	 * <li>An exception or error is thrown while executing {@code tick()}, in
	 *     which case that exception/error will propagate through this method.
	 * </ul>
	 */
	@Override
	public final void run() {
		running = true;
		lastTime = System.nanoTime();
		
		while(running) {
			long sleepTime = tick();
			try {
				Thread.sleep(sleepTime);
			} catch(InterruptedException e) {
				log.postWarning("Interrupted while sleeping until next tick!");
			}
		}
	}
	
	/**
	 * Executes this AppDriver.
	 * 
	 * <p>If invoked at regular intervals, this method ensures {@link
	 * #update()} is invoked as many times per second equivalent to {@code
	 * updatesPerSecond} as specified in the {@link #AppDriver(int, Log)
	 * constructor}. Furthermore, {@link #render()} is invoked every time this
	 * method is invoked.
	 * 
	 * @return The number of milliseconds to wait until this should be invoked
	 * again to ensure this is invoked as many times per second as specified by
	 * {@code fps} in the constructor. This is used by {@link #run()} and
	 * should generally be ignored.
	 * @throws IllegalStateException if this is invoked while a tick is in
	 * progress.
	 */
	public final long tick() {
		if(ticking)
			throw new IllegalStateException("A tick is already in progress!");
		ticking = true;
		
		long now = System.nanoTime();
		unprocessed += now - lastTime;
		
		// Make sure nothing has gone wrong with timing. This block will
		// certainly be passed through when this is invoked for the first time,
		// as lastTime will be 0.
		if(unprocessed > 5000000000L) { // 5 seconds
			log.postWarning("Can't keep up! Running "
					+ ((now - lastTime) / 1000000L) + " milliseconds behind; skipping " 
					+ (unprocessed / nsPerTick) + " ticks!"
			);
			unprocessed = nsPerTick; // let at least one tick happen
		} else if(unprocessed < 0L) {
			log.postWarning("Time ran backwards! Did the timer overflow?");
			unprocessed = 0L;
		}
		
		profiler.verify(2, "root.wait");
		profiler.next("update"); // end wait, start update
		
		// Perform any scheduled update ticks
		while(unprocessed >= nsPerTick) {
			numUpdates++;
			unprocessed -= nsPerTick;
			update();
		}
		
		profiler.verify(2, "root.update");
		profiler.end(); // end update
		
		// Flush the profiler every 1 second worth of ticks
		if(numUpdates - lastProfilerFlush >= ticksPerSecond) {
			lastProfilerFlush = numUpdates;
			profiler.flush();
		} else if(numUpdates < lastProfilerFlush) {
			// numUpdates must have overflowed
			lastProfilerFlush = numUpdates;
		}
		
		// Rendering
		profiler.start("render");
		render();
		
		profiler.verify(2, "root.render");
		profiler.next("wait");
		
		ticking = false;
		
		long usedNanos = System.nanoTime() - lastTime;
		lastTime = now;
		if(usedNanos < nsPerFrame)
			return (nsPerFrame - usedNanos) / 1000000L; // convert to millis
		else
			return 0L;
	}
	
	/**
	 * Performs an update tick.
	 * 
	 * @see #tick()
	 */
	protected abstract void update();
	
	/**
	 * Performs any rendering.
	 * 
	 * @see #tick()
	 */
	protected abstract void render();
	
	/**
	 * Stops this driver from executing, if it is being run as per {@link
	 * #run()}. This is equivalent to setting {@link #running} to {@code
	 * false}.
	 */
	public final void stop() {
		running = false;
	}
	
	/**
	 * @return The number of update ticks which have been executed during the
	 * lifetime of the application.
	 */
	public final long getUpdateCount() {
		return numUpdates;
	}
	
	/**
	 * @return The number of renders which have been executed during the
	 * lifetime of the application.
	 */
	public final long getRenderCount() {
		return numRenders;
	}
	
}
